"""Manages the state of a source-to-sink glacial sediment transport model."""

import numpy as np
import jax
import jax.numpy as jnp
import equinox as eqx
import dataclasses

from landlab import ModelGrid
from utils import StaticGrid
from utils.static_grid import freeze_grid

class ModelState(eqx.Module):
    """Store variable fields, shared parameters, and elapsed time.

    Required input variables (defined on grid nodes):
        grid: StaticGrid object representing the model domain.
        ice_thickness: Thickness of the glacier, ice cap, or ice sheet.
        surface_elevation: Elevation of the top surface of the ice mass.
        sliding_velocity: Sliding velocity mapped onto grid links.
        geothermal_heat_flux: Heat flux from the underlying geotherm.
        water_pressure: Pressure of water in the subglacial drainage system.

    Derived variables:
        bedrock_elevation: Difference between surface elevation and ice thickness.
        surface_slope: Slope of the ice surface.
        bedrock_slope: Slope of the bedrock beneath the glacier.
        node_is_terminus: Boolean array indicating terminus nodes.
        ice_mask: Boolean array where ice thickness > a threshold value.
        overburden_pressure: Hydrostatic pressure at the base of the ice mass.
        shear_stress: Basal shear stress derived from sliding and pressure.
        frictional_heat_flux: Heat generated by friction at the ice-bed interface.
        effective_pressure: Difference between overburden and water pressure.
        melt_rate: Specific (length / time) rate of melt at the base of the ice mass.

    Model variables
        till_thickness: Thickness of the (eroded) till layer beneath the ice mass.
        fringe_thickness: Thickness of the frozen fringe layer in the base of the ice mass.
        dispersed_thickness: Thickness of the dispersed layer above the frozen fringe.
    """

    # Components
    grid: StaticGrid

    # Glacier geometry
    ice_thickness: jax.Array = eqx.field(converter = jnp.asarray)
    surface_elevation: jax.Array = eqx.field(converter = jnp.asarray)
    surface_slope: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    bedrock_elevation: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    bedrock_slope: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    node_is_terminus: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    ice_mask: jax.Array = eqx.field(converter = jnp.asarray, init = False)

    # Ice dynamics
    overburden_pressure: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    sliding_velocity: jax.Array = eqx.field(converter = jnp.asarray)
    shear_stress: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    frictional_heat_flux: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    geothermal_heat_flux: jax.Array = eqx.field(converter = jnp.asarray)

    # Hydrology
    water_pressure: jax.Array = eqx.field(converter = jnp.asarray)
    effective_pressure: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    melt_rate: jax.Array = eqx.field(converter = jnp.asarray, init = False)

    # Sediment transport
    till_thickness: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    fringe_thickness: jax.Array = eqx.field(converter = jnp.asarray, init = False)
    dispersed_thickness: jax.Array = eqx.field(converter = jnp.asarray, init = False)

    # Physical parameters
    time_elapsed: float = 0.0
    sec_per_a: int = 31556926
    gravity: float = 9.81
    water_density: float = 1000
    water_viscosity: float = 1.8e-3
    ice_density: float = 917
    ice_latent_heat: float = 3.34e5

    slip_law_coefficient: float = 3.4e-4
    slip_law_exponent: int = 5
    till_friction_angle: float = jnp.deg2rad(30)

    # Numerical parameters
    min_ice_thickness: float = 0.1
    min_fringe_thickness: float = 1e-3

    def __post_init__(self):
        self.surface_slope = self.grid.calc_slope_at_node(self.surface_elevation)
        self.bedrock_elevation = self.surface_elevation - self.ice_thickness
        self.bedrock_slope = self.grid.calc_slope_at_node(self.bedrock_elevation)
        self.node_is_terminus = jnp.where(
            (self.grid.status_at_node != 0) & (self.bedrock_elevation < 0), 1, 0
        )
        self.ice_mask = jnp.where(self.ice_thickness > self.min_ice_thickness, 1, 0)
        self.overburden_pressure = (
            self.ice_density * self.gravity * self.ice_thickness
        )
        self.effective_pressure = self.overburden_pressure - self.water_pressure
        self.shear_stress = self.calc_shear_stress()
        self.frictional_heat_flux = jnp.abs(
            self.grid.map_mean_of_links_to_node(self.sliding_velocity) * self.shear_stress
        )
        self.melt_rate = (
            (self.geothermal_heat_flux + self.frictional_heat_flux)
            / (self.ice_density * self.ice_latent_heat)
        )

        self.till_thickness = jnp.full(self.grid.number_of_nodes, 0.0)
        self.fringe_thickness = jnp.full(self.grid.number_of_nodes, self.min_fringe_thickness)
        self.dispersed_thickness = jnp.full(self.grid.number_of_nodes, 0.0)

    def calc_shear_stress(self):
        """Calculate shear stress at grid nodes (Zoet and Iverson, 2020)."""
        velocity_magnitude = jnp.abs(
            self.grid.map_mean_of_links_to_node(self.sliding_velocity)
        )
        threshold_velocity = self.slip_law_coefficient * self.effective_pressure
        velocity_factor = jnp.float_power(
            velocity_magnitude / (velocity_magnitude + threshold_velocity),
            1 / self.slip_law_exponent
        )

        return jnp.where(
            self.ice_mask,
            self.effective_pressure * jnp.tan(self.till_friction_angle) * velocity_factor,
            0.0
        )


# IMPORTANT: this needs to stay as a top-level function, not a class function.
# (Because jax.jit will not accept strings as valid JAX types.)

def initialize_state_from_grid(grid: ModelGrid) -> ModelState:
    """Instantiate a model state from an existing Landlab grid."""
    for required in [
        'ice_thickness', 
        'surface_elevation', 
        'geothermal_heat_flux', 
        'water_pressure'
    ]:
        if required not in grid.at_node.keys():
            raise AttributeError("Missing " + required + " at grid nodes.")
    
    for required in ['sliding_velocity']:
        if required not in grid.at_link.keys():
            raise AttributeError("Missing " + required + " at grid links.")

    static = freeze_grid(grid)

    return ModelState(
        static,
        grid.at_node['ice_thickness'],
        grid.at_node['surface_elevation'],
        grid.at_link['sliding_velocity'],
        grid.at_node['geothermal_heat_flux'],
        grid.at_node['water_pressure']
    )

# More utility one-liners for inspecting state
# self.data_vars = [i.name for i in dataclasses.fields(ModelState) if i.type == jax.Array]
# self.vars_at_node = [i for i in self.data_vars if len(getattr(self, i)) == self.grid.number_of_nodes]
# self.vars_at_link = [i for i in self.data_vars if len(getattr(self, i)) == self.grid.number_of_links]